{% if current_user.role == 'admin' %}
  {% extends 'admin/adminbase.html' %}
{% else %}
  {% extends 'user/userbase.html' %}
{% endif %}

{% block content %}
<div class="d-flex">
<div class="container mt-5 text-center">
  <h2 class="mb-4">Edit Profile</h2>

  <div class="d-flex justify-content-center">
    <div style="background-color: #fff; border-radius: 20px; padding: 30px; width: 400px;">
      <form method="POST" action="{{ url_for('dashboard.editProfile') }}">
        {{ form.hidden_tag() }}
        <div style="display: none;">
          {{ form.loginPrivateKey }}
          {{ form.loginSalt }}
          {{ form.loginIV }}
          {{ form.encPrivateKey }}
          {{ form.encSalt }}
          {{ form.encIV }}
          <input type="hidden" name="keyProofSig">
          <input type="hidden" name="newPasswordHash">
        </div>

        <div class="mb-3 text-start">
          {{ form.email.label(class="form-label") }}
          {{ form.email(class="form-control", type="email", autocomplete="email", inputmode="email", placeholder="you@example.com") }}
          {% for error in form.email.errors %}
            <div class="text-danger small">{{ error }}</div>
          {% endfor %}
        </div>

        <div class="mb-3 text-start">
          {{ form.username.label(class="form-label") }}
          {{ form.username(class="form-control") }}
        </div>

        <!-- Only show current password field if new password is entered -->
        <div class="mb-3 text-start">
          {{ form.new_password.label(class="form-label") }}
          <input type="password" class="form-control" name="new_password" id="new_password"
            pattern="^(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+={}\[\]:;<>,.?/~`\\|^\-]).{8,}$"
            title="Password must be at least 8 characters long and include an uppercase letter, a digit, and a special character."
            placeholder="">
          {% for error in form.new_password.errors %}
          <div class="text-danger small">{{ error }}</div>
          {% endfor %}
        </div>

        <div class="mb-4 text-start">
          {{ form.current_password.label(class="form-label") }}
          <input type="password" class="form-control" name="current_password" id="current_password"
            placeholder="(Only required for changing password)">
        </div>

        <button type="submit" class="btn btn-dark w-100">{{ form.submitBtn.label.text }}</button>
      </form>

    </div>
  </div>
</div>
<script src="{{ url_for('static', filename='js/crypto.js') }}"></script>
<script id="ss-current-json" type="application/json">
{{ {
  "loginEncrypted": current_user.loginPrivateKey_encrypted,
  "loginSaltB64":   current_user.loginSalt,
  "loginIVB64":     current_user.loginIV,
  "encEncrypted":   current_user.encPrivateKey_encrypted,
  "encSaltB64":     current_user.encSalt,
  "encIVB64":       current_user.encIV
} | tojson }}
</script>

<script id="ss-chal" type="application/json">{{ edit_challenge | tojson }}</script>

<script>
(() => {
  if (window.__SS_CHANGE_PASS_BOUND__) return;
  window.__SS_CHANGE_PASS_BOUND__ = true;

  const form = document.querySelector("form");
  if (!form) return;

  const newPassInput = form.querySelector('[name="new_password"]');
  const currentPassInput = form.querySelector('[name="current_password"]');

  let CURRENT = {}, CHAL = "";
  try {
    CURRENT = JSON.parse(document.getElementById("ss-current-json")?.textContent || "{}");
    CHAL    = JSON.parse(document.getElementById("ss-chal")?.textContent || '""');
  } catch {
    alert("Unable to read crypto material. Please reload the page.");
    return;
  }

  form.addEventListener("submit", async (event) => {
    if (!form.reportValidity()) return;

    event.preventDefault();

    const newPassword = newPassInput?.value || "";
    const currentPassword = currentPassInput?.value || "";

    const bothEmpty = !newPassword && !currentPassword;
    const oneOnly = (newPassword && !currentPassword) || (!newPassword && currentPassword);

    if (oneOnly) {
    if (newPassword && !currentPassword) {
      // trying to set a new password without current → block & inform
      alert("Enter both your current and new password to update it.");
      return; // nothing sent
    }
    // current provided but no new password → treat as profile-only
    if (newPassInput) { newPassInput.value = ""; newPassInput.removeAttribute("name"); }
    if (currentPassInput) { currentPassInput.value = ""; currentPassInput.removeAttribute("name"); }
    form.submit(); // submit without any password fields
    return;
    }

      // If BOTH empty → normal profile-only submit (ensure names removed just in case)
    if (bothEmpty) {
    if (newPassInput) newPassInput.removeAttribute("name");
    if (currentPassInput) currentPassInput.removeAttribute("name");
    form.submit();
    return;
    }

    const changingPassword = !!(newPassword || currentPassword);
    if (changingPassword) {
    // Require both fields if user intends to rotate
    if (!newPassword || !currentPassword) {
    alert("Enter both your current and new password.");
    return; // stop submission
    }

    // Strength policy: ≥8 chars, at least one uppercase, one digit, one special
    const strongEnough =
    newPassword.length >= 8 &&
    /[A-Z]/.test(newPassword) &&
    /\d/.test(newPassword) &&
    /[!@#$%^&*()_+={}\[\]:;<>,.?/~`\\|^\-]/.test(newPassword);

    if (!strongEnough) {
    alert("New password must be at least 8 characters and include an uppercase letter, a digit, and a special character.");
    return; // stop submission; nothing sent to server
    }
}
    // Not changing password → let profile-only update go through untouched
    if (!newPassword && !currentPassword) return;
    
    try {
      // 1) Derive OLD keys
      const oldLoginKey = await deriveKeyFromPassword(currentPassword, CURRENT.loginSaltB64);
      const oldEncKey   = await deriveKeyFromPassword(currentPassword, CURRENT.encSaltB64);

      // 2) Decrypt old private keys
      const loginPrivKey = await decryptLoginPrivateKey(CURRENT.loginEncrypted, oldLoginKey, CURRENT.loginIVB64);
      const encPrivKey   = await decryptEncPrivateKey(CURRENT.encEncrypted,   oldEncKey,   CURRENT.encIVB64);
      if (!loginPrivKey || !encPrivKey) {
        alert("Current password is incorrect or key decryption failed.");
        return;
      }

      // 3) Sign server challenge (zero-knowledge proof of ownership)
      const sigB64 = await signData(CHAL, loginPrivKey);
      form.querySelector('[name="keyProofSig"]').value = sigB64;

      // 4) New salts (generateSalt() already returns Base64 — do NOT re-encode)
      const newLoginSaltB64 = generateSalt();
      const newEncSaltB64   = generateSalt();

      // 5) Derive NEW keys
      const newLoginKey = await deriveKeyFromPassword(newPassword, newLoginSaltB64);
      const newEncKey   = await deriveKeyFromPassword(newPassword, newEncSaltB64);

      // 6) Re-encrypt same private keys with new derived keys
      const loginEncrypted = await encryptPrivateKey(loginPrivKey, newLoginKey);
      const encEncrypted   = await encryptPrivateKey(encPrivKey,   newEncKey);

      // 7) Populate hidden fields (opaque blobs only)
      form.querySelector('[name="loginPrivateKey"]').value = arrayBufferToBase64(loginEncrypted.encryptedPrivateKey);
      form.querySelector('[name="loginSalt"]').value       = newLoginSaltB64;
      form.querySelector('[name="loginIV"]').value         = arrayBufferToBase64(loginEncrypted.iv);

      form.querySelector('[name="encPrivateKey"]').value   = arrayBufferToBase64(encEncrypted.encryptedPrivateKey);
      form.querySelector('[name="encSalt"]').value         = newEncSaltB64;
      form.querySelector('[name="encIV"]').value           = arrayBufferToBase64(encEncrypted.iv);

      // 8) Optional: send a bcrypt hash for the new password (server stores directly)
      if (window.dcodeIO?.bcrypt) {
        const bcryptHash = await new Promise((resolve, reject) => {
          window.dcodeIO.bcrypt.genSalt(12, (e, salt) => e ? reject(e) :
            window.dcodeIO.bcrypt.hash(newPassword, salt, (e2, hash) => e2 ? reject(e2) : resolve(hash)));
        });
        form.querySelector('[name="newPasswordHash"]').value = bcryptHash;
      }

      // 9) SCRUB plaintext so no password is posted at all
      if (newPassInput) { newPassInput.value = ""; newPassInput.removeAttribute("name"); }
      if (currentPassInput) { currentPassInput.value = ""; currentPassInput.removeAttribute("name"); }

      form.submit();
    } catch (err) {
      console.error("Password change error:", err);
      alert("An error occurred while updating your password.");
    }
  });
})();
</script>

</div>

{% endblock %}
